mindbender: {
  artifacts: {
    ################################################################
    Entity_temporal : {
      from: { s: Sentence }
      using: {
        zlib: python('/udf/z-lib.py')
        zext: python('/udf/z-ext_temporal_local.py')
      }
      let: {
        all_phrases: zlib.get_all_phrases_in_sentence(s.words, 3)
        res: zext.main (s.words, all_phrases)
      }
      return: {
        from: { r: res }
        return: {
          sent       : s            :: Sentence
          start      : r.start      :: bigint
          end        : r.end        :: bigint
          type       : r.type       :: text
          entity     : r.entity     :: text
          is_correct : r.is_correct :: boolean
        }
      }
    }
    ################################################################
    Entity_formation_local : {  # Similar to Entity_temporal
      from: { s: Sentence }
      using: {
        zlib: python('/udf/z-lib.py')
        zext: python('/udf/z-ext_formation_local.py')
      }
      let: {
        all_phrases: zlib.get_all_phrases_in_sentence(s.words, 5)
        res: zext.main (s.words, s.ners, s.lemmas, all_phrases)
      }
      return: {
        from: { r: res }
        return: {
          sent       : s            :: Sentence
          start      : r.start      :: bigint
          end        : r.end        :: bigint
          type       : r.type       :: text
          entity     : r.entity     :: text
          is_correct : r.is_correct :: boolean
        }
      }
    }

    # NOTE: This artifact is not in an original appl.conf!
    # TODO: We should be able to make a table using "GROUP BY".
    Entity_formation_gp: {
      from: { e: Entity_formation_local }
      return: {
        groupby:  e...docid                     ########## HERE!
        return: { entity_objs : array_agg(e) }  ########## HERE!
      }
    }

    Entity_formation_global: {
      from: {
        s: Sentence
        e_gp: Entity_formation_gp
      }
      where: [ s.docid = e_gp...docid ]
      using: {
        zlib: python('/udf/z-lib.py')
        zext: python('/udf/z-ext_formation_global.py')
      }
      let:   {
        all_phrases: zlib.get_all_phrases_in_sentence(s.words, 5)
        dicts: zext.aux(e_gp...entities, e_gp...types)
        res: zext.main(s.words, s.lemmas, all_phrases,
                       dicts.good_names, dicts.local_entities, dicts.local_entity_types)
      }
      return: {
        from: { r: res }
        return: {
          sent       : s            :: Sentence
          start      : r.start      :: bigint
          end        : r.end        :: bigint
          type       : r.type       :: text
          entity     : r.entity     :: text
          is_correct : r.is_correct :: boolean
        }
      }
    }

    # NOTE: This artifact is not in an original appl.conf!
    # TODO: We should be able to insert new rows into a previously created table.
    # For now, we make an additional artifact that merges two tables (= local and global ones).
    Entity_formation: {
      from: {
        e_local:  Entity_formation_local
        e_global: Entity_formation_global
      }
      return: [
        { return: { content : e_local  :: Entity_formation_local  } }
        { return: { content : e_global :: Entity_formation_global } }
      ]
    }
    ################################################################
    # NOTE: This artifact is not in an original appl.conf!
    Entity: {
      from: {
        e_for: Entity_formation
        e_tem: Entity_temporal
        e_tax: Entity_taxon
        e_loc: Entity_location
      }
      return: [
        { return: {
            type       : 'FORMATION' :: text
            entity_obj : e_for       :: Entity_formation
          } }
        { return: {
            type       : 'INTERVAL'  :: text
            entity_obj : e_tem       :: Entity_temporal
          } }
        { return: {
            type       : 'TAXON-' || e_tax...type :: text
            entity_obj : e_tax       :: Entity_taxon
          } }
        { return: {
            type       : 'LOCATION'  :: text
            entity_obj : e_loc       :: Entity_location
          } }
      ]
    }
    
    # NOTE: This artifact is not in an original appl.conf!
    # TODO: We should be able to make a table using "GROUP BY".
    Entity_gp: {
      from: { e: Entity }
      return: {
        groupby:  e...docid                                ########## HERE!
        return: { entity_objs : array_agg(e) :: Entity[]}  ########## HERE!
      }
    }

    # TODO: We should be able to pass to a python function a user-created array of values
    Relation_candidate: {
      from: {
        s: Sentence
        e_gp: Entity_gp
      }
      where: [ s.docid = e_gp...docid ]
      using: {
        zlib: python('/udf/z-lib.py')
        zext: python('/udf/z-ext_relation_samesent.py') }
      let:   {
        entities: zext.aux(s.sentid,
                           e_gp.entity_objs,
                           e_gp.entity_objs[].type,      ######### HERE!
                           e_gp.entity_objs[]...sentid,  ######### HERE!
                           e_gp.entity_objs[]...start,   ######### HERE!
                           e_gp.entity_objs[]...end,     ######### HERE!
                           e_gp.entity_objs[]...entity)  ######### HERE!
        res: zext.main(s.words, s.ners, entities)
      }
      return: {
        from: { r: res }
        return: {
          e1       : r.e1       :: Entity
          e2       : r.e2       :: Entity
          type     : r.type     :: text
          features : r.features :: text
        }
      }
    }
    ################################################################
    Relation_formationtemporal: {
      # TODO: How to express "SELECT DISTINCT" in our syntax?
      from: { rel: Relation_candidate }
      where: [ rel.type = 'FORMATIONINTERVAL' ]
      using: {
        zsup: python('/udf/z-supervise_formationtemporal.py')
      }
      let: {
        res: zsup.main(rel.e1...entity, rel.e2...entity)
      }
      return: {
        rel        : rel :: Relation_candidate
        is_correct : res :: boolean
      }
    }
    ################################################################
  }
}


### Q: What is the exact semantics of "return" block?
################################################################
      return: {
        from: { r: res }
        return: {
          aaa : r.a :: A
          bbb : r.b :: B
      }
      ################
      return: {
        aaa : a :: A
        bbb : b :: B
      }
      ################
      return: [
        # when returning multiple
        {
          from: { r: res }
          return: {
            aaa : r.a :: A
            bbb : r.b :: B
          }
        }
        # when returning just one
        {
          return: {
            aaa : a :: A
            bbb : b :: B
          }
        }
      ]
################################################################
